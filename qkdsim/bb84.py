# -*- coding: utf-8 -*-
"""
This module contains the class for the BB84 protocol and main() to run it
"""

from parties import Sender, Receiver, Adversary
from channels import QuantumChannel, ClassicalChannel
from displayer import ConsoleTablePrinter
from hardware import PhotonSource, PhotonDetector


def main():

    alice = Sender(name='Alice', photon_src=PhotonSource(error_rate=0))
    bob = Receiver(name='Bob', photon_detector=PhotonDetector(loss_rate=0))
    eve = Adversary()

    qu_chan = QuantumChannel(0)
    cl_chan = ClassicalChannel()

    initial_key_length = 6

    qkd_run = BB84(alice, bob, eve, initial_key_length, qu_chan,
                   cl_chan, ConsoleTablePrinter())

    qkd_run.initialise()
    qkd_run.send_key_as_photons()
    qkd_run.sift_keys()
    qkd_run.estimate_error()

    return


class BB84(object):
    """
    BB84 protocol

    Parameters
    ----------
    sender: Sender
        aka Alice

    receiver: receiver
        aka Bob

    adversary: Adversary
        aka Eve

    init_key_len: int
        Initial length of the random bit array generated by the sender
        which will become the shared secret key

    qu_chan: QuantumChannel
        Quantum channel used to share photons between sender and receiver

    cl_chan: ClassicalChannel
        Classical channel used to share messages between sender and receiver
    """

    def __init__(self, sender, receiver, adversary, init_key_len,
                 qu_chan, cl_chan, displayer):
        self.sender = sender
        self.receiver = receiver
        self.adversary = adversary
        self.qu_chan = qu_chan
        self.cl_chan = cl_chan
        self.n = init_key_len
        self.displayer = displayer

    def initialise(self):
        """
        Initialise QKD

        Generate random key and bases for sender
        """
        self.sender.generate_initial_key(self.n)
        self.sender.generate_sending_bases(self.n)

        self.display_initialise()
        return

    def send_key_as_photons(self):
        """
        * generate photons from sender's key and bases
        * send them through the quantum channel to receiver
        * generate random bases for receiver
        * generate receiver's initial key by measuring photons
        """
        self.receiver.generate_receiving_bases(self.n)
        self.receiver.key = [None] * self.n  # TODO update for future loss
        generated_photons = self.sender.send_photons(self.qu_chan)
        self.receiver.receive_photons(self.qu_chan)
        self.display_send_key_as_photons(generated_photons)
        return

    def sift_keys(self):
        """
        Communicate over classical channel to establish which photons
        receiver measured in correct basis and remove incorrect or missing
        bits from both sender's and receiver's keys
        """
        self.receiver.send_bases(self.cl_chan)
        # sender receive bases
        # sender calculate which bases correct
        # sender delete incorrect from her key (set to none?)
        # sender send which bases correct to receiver
        # receiver update their key (remove incorrect bases)
        
        # old sifting:
        self.sender.cl_chan.send( self.sender.sending_bases)
        self.reciever.cl_chan.send( self.reciever.receiving_bases)
        
        compareBasesAndSiftKey(self.sender,self.reciever.cl_chan.receive()) #Alice compares her bases with Bob bases and remove the bits of key that doesnt much
        compareBasesAndSiftKey(self.receiver,self.sender.cl_chan.receive()) #Bob does the same
        
        self.display_sift_keys()
        return

    def parity_creation(self):
        """
        * Create parity of keys.
        This method will add one last bit to the key with the parity check. Parity bit = 1 if parity even, 0 if uneven
        """
        a = self.sender.key
        b = self.reciever.key
        a_parity = 0
        b_parity = 0
        if ((a.sum(axis=0) % 2) == 0):
            a_parity=1
            a.append(a_parity)
        
        if ((b.sum(axis=0) % 2) == 0):
            b_parity=1
            b.append(b_parity)
        return
    
    def parity_check(self):
        """
        * Check parity of keys to see if there are errors on Alice and Bob keys.
        """
        a = self.sender.key
        b = self.reciever.key
        a_parity = a[-1] #get parity bit
        b_parity = b[-1] #get parity bit
        error_corr = False
        
        self.reciever.cl_chan.send(b_parity)
        self.sender.cl_chan.send(a_parity)
        
        if(( self.sender.cl_chan.receive() == b_parity) and (self.receiver.cl_chan.receive() == a_parity)):
            print("Sucesful parity check")
        else:
            print("Unsucesful parity check")
            error_corr = True #use to decide if we need to perform error corr or not

        return



    def estimate_error(self):
        """
        Communicate subset of key over classical channel to estimate error
        and remove shared bits
        """
        self.display_estimate_error()
        return

    def display_initialise(self):
        self.displayer.display_initialise(
                self.sender.name,
                self.sender.key,
                self.sender.sending_bases,
                )
        return

    def display_send_key_as_photons(self, gend_photons):
        self.displayer.display_send_key_as_photons(
                gend_photons,
                self.receiver.name,
                self.receiver.receiving_bases,
                self.receiver.key
                )
        return

    def display_sift_keys(self):
        self.displayer.display_sift_keys()
        return

    def display_estimate_error(self):
        self.displayer.display_estimate_error()
        return


if __name__ == '__main__':
    main()

def compareBasesAndSiftKey(self,user,op_base):
        count =0
        for count in range (0,op_base.__sizeof__()):
                if(op_base[count] == user.sending_bases):
                    pass
                else:
                    del user.key[count]
        return